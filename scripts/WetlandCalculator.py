import arcpyfrom arcpy import envfrom math import atan2, pi, exp# import log toolimport osimport syssys.path.append(os.path.join(os.path.dirname(__file__), "../helpers"))from printmessages import printMessages as log# TODO: calculate storage tool to be used with dam removal or dam creation, basically just diffs the existing and removed dems# TODO: burn in channel width at channel depth via buffer of channel width into demclass PotentialWetlands(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Model Potential Wetlands"        self.description = "Model potential wetlands from DEM"        self.category = "Wetland Tools"        self.canRunInBackground = False       def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="DEM",            name="dem",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Analysis Area",            name="analysis_area",            datatype="GPExtent",            parameterType="Required",            direction="Input")                param1.controlCLSID = '{15F0D1C1-F783-49BC-8D16-619B8E92F668}'        param2 = arcpy.Parameter(            displayName="Output Features",            name="out_features",            datatype="DEFeatureClass",            direction="Output")        param2.parameterDependencies = [param0.name]        param2.schema.clone = True        param3 = arcpy.Parameter(            displayName="Maximum Slope (percent)",            name="max_slope",            datatype="GPDouble",            parameterType="Optional",            direction="Output")        param4 = arcpy.Parameter(            displayName="Soils Shapefile",            name="soils",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        param4.filter.list = ["Polygon"]                param5 = arcpy.Parameter(            displayName="HSG Field",            name="hsg_field",            datatype="GPString",            parameterType="Required",            direction="Input")        param5.filter.type = "ValueList"        param5.filter.list = []        param6 = arcpy.Parameter(            displayName="Valid HSGs",            name="hsg_values",            multiValue = True,            datatype="GPString",            parameterType="Required",            direction="Input")        param6.filter.type = "ValueList"        param6.filter.list = []        param7 = arcpy.Parameter(            displayName="Land Use Data",            name="land_use",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param8 = arcpy.Parameter(            displayName="Land Use Field",            name="land_use_field",            datatype="GPString",            parameterType="Required",            direction="Input")        param8.filter.type = "ValueList"        param8.filter.list = []        param9 = arcpy.Parameter(            displayName="Land Uses to Include",            name="land_use_field_values",            datatype="GPString",            multiValue=True,            parameterType="Required",            direction="Input")        param9.filter.type = "ValueList"        param9.filter.list = []        param10 = arcpy.Parameter(            displayName="Exclude Mapped Wetlands?",            name="exclude_wetlands",            datatype="GPBoolean",            parameterType="Optional",           direction="Input")        param11 = arcpy.Parameter(            displayName="Wetland Layers",            name="wetland_layers",            datatype="GPFeatureLayer",            multiValue=True,            parameterType="Optional",           direction="Input")        param11.filter.list = ["Polygon"]                params = [param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11]        return params    def updateParameters(self, parameters):        # get soils field        if parameters[4].value:            parameters[5].enabled = True            fields = [f.name for f in arcpy.ListFields(parameters[4].value)]            parameters[5].filter.list = fields        if not parameters[4].value:            parameters[5].enabled = False            parameters[5].value = None                    # toggle which soil hsg values to use        if parameters[5].value:            parameters[6].enabled = True            values = set()            with arcpy.da.SearchCursor(parameters[4].value, parameters[5].value) as cursor:                for row in cursor:                    if row[0] != None:                        values.add(row[0])            values = sorted(list(values))##            for f in arcpy.ListFields(parameters[4].value):##                if f.aliasName == parameters[5].value:##                    with arcpy.da.SearchCursor(parameters[4].value, f.name) as cursor:##                        for row in cursor:##                            if row[0] != None:##                                values.add(row[0])##                    values = sorted(list(values))            parameters[6].filter.list = values        if not parameters[5].value:            parameters[6].enabled = False        # get land use field        if parameters[7].value:            parameters[8].enabled = True            fields2 = [f2.name for f2 in arcpy.ListFields(parameters[7].value)]            parameters[8].filter.list = fields2        if not parameters[7].value:            parameters[8].enabled = False        # toggle which land use values to use        if parameters[8].value:            parameters[9].enabled = True            values2 = []            with arcpy.da.SearchCursor(parameters[7].value, parameters[8].value) as cursor2:                    values2 = sorted({row2[0] for row2 in cursor2})            parameters[9].filter.list = values2        if not parameters[7].value:            parameters[9].enabled = False                    # default maximum slope value        if parameters[3].value == None:            parameters[3].value = 5        # toggle asking for wetland layers        if parameters[10].value == True:            parameters[11].enabled = True        else:            parameters[11].enabled = False                              return        def execute(self, parameters, messages):        """The source code of the tool."""        # Setup        arcpy.env.overwriteOutput = True        dem_raster = parameters[0].value        extent = arcpy.Extent(XMin = parameters[1].value.XMin,                              YMin = parameters[1].value.YMin,                              XMax = parameters[1].value.XMax,                              YMax = parameters[1].value.YMax)        extent.spatialReference = parameters[1].value.spatialReference        output_file = parameters[2].valueAsText        max_slope = parameters[3].value if parameters[3].value else 8        soils_shapefile = parameters[4].value        soils_hsg_field = parameters[5].value        hsg_values = parameters[6].valueAsText.split(";")        land_use_raster = parameters[7].value        land_use_field = parameters[8].value        land_use_values = parameters[9].valueAsText.replace("'","").split(";")        calculate_wetlands = parameters[10].value        wetland_layers = parameters[11].valueAsText.replace("'","").split(";") if calculate_wetlands else []        # project setup        project = arcpy.mp.ArcGISProject("Current")        active_map = project.activeMap        # setup DEM area        log("clipping DEM")        scratch_dem = arcpy.CreateScratchName("temp",                                               data_type="RasterDataset",                                               workspace=arcpy.env.scratchFolder)               rectangle = "{} {} {} {}".format(extent.XMin, extent.YMin, extent.XMax, extent.YMax)        arcpy.management.Clip(dem_raster, rectangle, scratch_dem)        #dem_raster_clip = "{}\\dem_raster_clip".format(arcpy.env.workspace)        #out_raster_clip = arcpy.sa.ExtractByMask(dem_raster, scratch_stream_buffer, "INSIDE", "MINOF")        #out_raster_clip.save(dem_raster_clip)                # slope raster        log("creating slope raster from DEM")        scratch_slope = arcpy.CreateScratchName("temp",                                               data_type="RasterDataset",                                               workspace=arcpy.env.scratchFolder)        out_slope = arcpy.sa.Slope(scratch_dem, "PERCENT_RISE", "", "GEODESIC", "METER")        out_slope.save(scratch_slope)        # slopes < 5 percent        log("selecting slopes less than or equal to {}%".format(max_slope))        scratch_low_slope = arcpy.CreateScratchName("temp",                                               data_type="RasterDataset",                                               workspace=arcpy.env.scratchFolder)        slope_sql_query = "VALUE <= {}".format(max_slope)        outCon = arcpy.sa.Con(scratch_slope, scratch_slope, "", slope_sql_query)        outCon.save(scratch_low_slope)                    # convert con output to int        log("converting slope raster to int")        scratch_int_slope = arcpy.CreateScratchName("temp",                                               data_type="RasterDataset",                                               workspace=arcpy.env.scratchFolder)                scratch_int_slope = arcpy.sa.Int(scratch_low_slope)        # slope raster to polygon        log("converting slope raster to polygon")        scratch_slope_polygon = arcpy.CreateScratchName("temp",                                               data_type="FeatureClass",                                               workspace=arcpy.env.scratchFolder)        arcpy.conversion.RasterToPolygon(scratch_int_slope, scratch_slope_polygon, "NO_SIMPLIFY")        # dissolve raster polygon features        log("dissolving slope polygon boundaries")        scratch_slope_dissolve_polygon = arcpy.CreateScratchName("temp",                                               data_type="FeatureClass",                                               workspace=arcpy.env.scratchFolder)                arcpy.management.Dissolve(scratch_slope_polygon, scratch_slope_dissolve_polygon)                # clip soils layer to low slope area        log("clipping soils to low slope areas")        scratch_soils_area = arcpy.CreateScratchName("temp",                                               data_type="FeatureClass",                                               workspace=arcpy.env.scratchFolder)        arcpy.analysis.Clip(soils_shapefile, scratch_slope_dissolve_polygon, scratch_soils_area)        # select HSG: A/D, B/D, C/D, C, or D from soils        log("selecting hydric soils")        scratch_hsg_soils = arcpy.CreateScratchName("temp",                                               data_type="FeatureClass",                                               workspace=arcpy.env.scratchFolder)        hsg_sql_query = ""        for hsg in hsg_values:            hsg = hsg.replace("'", "")            if hsg_sql_query == "":                hsg_sql_query = "{} = '{}'".format(soils_hsg_field, hsg)            else:                hsg_sql_query += " Or {} = '{}'".format(soils_hsg_field, hsg)        arcpy.analysis.Select(scratch_soils_area, scratch_hsg_soils, hsg_sql_query)        # clip land use raster        log("clipping land use raster to valid soils area and slopes less than or equal to {}%".format(max_slope))        land_use_raster_clip = "{}\\land_use_raster_clip".format(arcpy.env.workspace)        out_land_use_raster_clip = arcpy.sa.ExtractByMask(land_use_raster, scratch_hsg_soils, "INSIDE", "MINOF")        out_land_use_raster_clip.save(land_use_raster_clip)        # select viable land uses from land use raster        log("extracting desired land uses")        scratch_land_use = "{}\\scratch_land_use".format(arcpy.env.workspace)        land_use_sql_query = ""        existing_values = []        with arcpy.da.SearchCursor(land_use_raster_clip, land_use_field) as cursor:            existing_values = sorted({row[0] for row in cursor})        land_use_values = [ i for i in land_use_values if i in existing_values ]         if len(land_use_values) != 0:            for value in land_use_values:                if land_use_sql_query == "":                    land_use_sql_query = "{} = '{}'".format(land_use_field, value)                else:                    land_use_sql_query += " Or {} = '{}'".format(land_use_field, value)            outLandUse = arcpy.sa.ExtractByAttributes(land_use_raster_clip, land_use_sql_query)            outLandUse.save(scratch_land_use)        else:            log("no valid land uses found in area, please try again with land uses found in analysis area")            return             # convert land usage output to polygon        log("converting land use areas to polygon")        scratch_land_use_polygon = arcpy.CreateScratchName("temp",                                               data_type="FeatureClass",                                               workspace=arcpy.env.scratchFolder)        arcpy.conversion.RasterToPolygon(scratch_land_use, scratch_land_use_polygon, "NO_SIMPLIFY", "VALUE")        # copy potential wetlands to new layer        log("copying potential wetlands to new layer")        potential_wetland_locations = arcpy.CreateUniqueName("potential_wetland_locations", arcpy.env.workspace)        arcpy.management.CopyFeatures(scratch_land_use_polygon, potential_wetland_locations)        # setup temporary potential wetland layer helper        scratch_reduced_potential_wetland = arcpy.CreateScratchName("temp",                                               data_type="FeatureClass",                                               workspace=arcpy.env.scratchFolder)         # erase NWI / DEC wetlands if selected        if calculate_wetlands:            log("erasing mapped wetlands from output")             for wetland_layer in wetland_layers:                # erase wetlands                try:                    arcpy.analysis.Erase(potential_wetland_locations, wetland_layer, scratch_reduced_potential_wetland)                except arcpy.ExecuteError:                    log("failed to erase existing wetlands, please see error below:")                    log(arcpy.GetMessages())                    sys.exit()                # copy reduced wetland area to potential wetland locations                arcpy.management.CopyFeatures(scratch_reduced_potential_wetland, potential_wetland_locations)        # delete not needed scratch layers        log("delete unused layers")        arcpy.management.Delete(land_use_raster_clip)        arcpy.management.Delete(scratch_land_use)        arcpy.management.Delete([scratch_dem, scratch_slope,scratch_low_slope,scratch_int_slope,scratch_slope_polygon,scratch_slope_dissolve_polygon,scratch_hsg_soils,scratch_soils_area,scratch_land_use_polygon,scratch_reduced_potential_wetland])        # finish up        log("finishing up")        active_map.addDataFromPath(potential_wetland_locations)        # save project        log("saving project")        project.save()        returnclass BermAnalysis(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Berm Analysis"        self.description = "Model backwatered area from berm"        self.category = "Wetland Tools"        self.canRunInBackground = False       def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="DEM",            name="dem",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Analysis Area",            name="analysis_area",            datatype="GPExtent",            parameterType="Required",            direction="Input")                param1.controlCLSID = '{15F0D1C1-F783-49BC-8D16-619B8E92F668}'        param2 = arcpy.Parameter(            displayName="Z-Unit",            name="z_unit",            datatype="GPString",            parameterType="Optional",            direction="Input")        param2.filter.list = ["METER", "FOOT"]        param3 = arcpy.Parameter(            displayName="Output Features",            name="out_features",            datatype="DEFeatureClass",            direction="Output")        param3.parameterDependencies = [param0.name]        param3.schema.clone = True        param4 = arcpy.Parameter(            displayName="Line",            name="line",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        param4.filter.list = ["Polyline"]        param4.controlCLSID = '{60061247-BCA8-473E-A7AF-A2026DDE1C2D}' # allows line creation                param5 = arcpy.Parameter(            displayName="Specify berm height?",            name="supply_berm_height",            datatype="GPBoolean",            parameterType="Optional",            direction="Input")                       param6 = arcpy.Parameter(            displayName="Max Berm Height (ft)",            name="berm_height",            datatype="GPDouble",            parameterType="Optional",            direction="Input")                param7 = arcpy.Parameter(            displayName="Add depth contours?",            name="contours",            datatype="GPBoolean",            parameterType="Optional",            direction="Input")                param8 = arcpy.Parameter(            displayName="Contour interval (ft)",            name="contour_interval",            datatype="GPDouble",            parameterType="Optional",            direction="Input")                param9 = arcpy.Parameter(            displayName="Output Contour Feature",            name="contour_output",            parameterType="Required",                        datatype="DEFeatureClass",            direction="Output")        param9.parameterDependencies = [param0.name]        param9.schema.clone = True                params = [param0, param1, param2, param3, param4, param5, param6, param7, param8, param9]        return params    def updateParameters(self, parameters):        # update parameters before execution if needed        # toggle asking for berm height        if parameters[0].value != None:            desc = arcpy.Describe(parameters[0].value)            parameters[2].value = desc.spatialReference.linearUnitName                if parameters[5].value == True:            parameters[6].enabled = True        else:            parameters[6].enabled = False        # default berm height        if parameters[6].value == None:            parameters[6].value = 5                # default contour interval        if parameters[8].value == None:            parameters[8].value = 1                    # toggle asking for default contour interval and output        if parameters[7].value == True:            parameters[8].enabled = True            parameters[9].enabled = True            if parameters[3].value:                            parameters[9].value = str(parameters[3].value) + "_contours_" + str(int(parameters[8].value)) + "ft"        else:            parameters[8].enabled = False            parameters[9].enabled = False                        return        def execute(self, parameters, messages):        """The source code of the tool."""        # Setup        arcpy.env.overwriteOutput = True        log("reading in parameters")        dem_raster = parameters[0].value               extent = arcpy.Extent(XMin = parameters[1].value.XMin,                              YMin = parameters[1].value.YMin,                              XMax = parameters[1].value.XMax,                              YMax = parameters[1].value.YMax)        extent.spatialReference = parameters[1].value.spatialReference        vertical_unit = parameters[2].value        z_unit = 3.2808 if "meter" in vertical_unit.lower() else 1        output_file = parameters[3].valueAsText        berms = parameters[4].value        supply_berm_height_bool = parameters[5].value        berm_height = parameters[6].value / z_unit        contour_bool = parameters[7].value        contour_interval = parameters[8].value        contour_output = parameters[9].valueAsText        # project setup        project = arcpy.mp.ArcGISProject("Current")        active_map = project.activeMap        # setup scratch variables        log("creating scratch variables")        scratch_dem = arcpy.CreateUniqueName("scratch_dem")        scratch_dem_min = arcpy.CreateUniqueName("scratch_dem_min")        scratch_zonal_statistics = arcpy.CreateUniqueName("scratch_zonal_statistics")        scratch_dem_mask = arcpy.CreateUniqueName("scratch_dem_mask")        scratch_mosaic_raster = arcpy.CreateUniqueName("scratch_mosaic_raster")        scratch_fill_mosaic = arcpy.CreateUniqueName("scratch_fill_mosaic")        scratch_fill_dem = arcpy.CreateUniqueName("scratch_fill_dem")        scratch_raster_calculator = arcpy.CreateUniqueName("scratch_raster_calculator")        scratch_con = arcpy.CreateUniqueName("scratch_con")        scratch_contour = arcpy.CreateUniqueName("scratch_contour")        scratch_effective_berm = arcpy.CreateUniqueName("scratch_effective_berm")        scratch_output = arcpy.CreateUniqueName("scratch_output")        scratch_berm = arcpy.CreateUniqueName("scratch_berm")        # get spatial reference        log("finding spatial reference")        spatial_reference_name = active_map.spatialReference.name        spatial_reference = arcpy.SpatialReference(spatial_reference_name)        log("creating output feature classes")        # create flooded area output        if not arcpy.Exists(output_file):            out_name = output_file.split("\\")[-1]            arcpy.management.CreateFeatureclass(                out_path=arcpy.env.workspace,                out_name=out_name,                geometry_type="POLYGON",                spatial_reference=spatial_reference            )        # create contour output        if contour_bool and not arcpy.Exists(contour_output):            out_name = contour_output.split("\\")[-1]            arcpy.management.CreateFeatureclass(                out_path=arcpy.env.workspace,                out_name=out_name,                geometry_type="POLYLINE",                spatial_reference=spatial_reference            )            # add contour field            arcpy.management.AddField(contour_output, "Contour", "DOUBLE")                         # setup DEM area        log("clipping DEM")              rectangle = "{} {} {} {}".format(extent.XMin, extent.YMin, extent.XMax, extent.YMax)        arcpy.management.Clip(dem_raster, rectangle, scratch_dem)        # add berm height field to berm fc        if "berm_height" not in [f.name for f in arcpy.ListFields(berms)]:            arcpy.management.AddField(berms, "berm_height", "FLOAT", field_precision=255, field_scale=2)                 # get OID field name for berm fc        oidfield = arcpy.Describe(berms).OIDFieldName        # get selected features in layer        selection_set = berms.getSelectionSet()        expression = "*"        if selection_set:            selection_tuple = tuple(selection_set)            selection = "("+",".join([str(i) for i in selection_tuple])+")"            expression = "{0} IN{1}".format(arcpy.AddFieldDelimiters(berms,oidfield),selection)        # iterate through berms        with arcpy.da.UpdateCursor(berms, [oidfield, "berm_height"], expression) as cursor:            for berm in cursor:                               # make a temporary feature layer to store the berm for zonal analysis                log("creating temporary berm feature for analysis")                oid_value = berm[0]                where_clause = "\"OBJECTID\" = " + str(oid_value)                arcpy.analysis.Select(berms, scratch_berm, where_clause)                                # ensure berm is in rectangle, if not skip                desc = arcpy.Describe(scratch_berm)                if not extent.contains(desc.extent):                    log("drawn berm not in analysis area, skipping")                    continue                                # if berm height is supplied, add it to the lowest elevation to get the flat berm elevation                if supply_berm_height_bool:                    # find minimum berm elevation                    log("setting berm elevation")                    out_raster = arcpy.sa.ZonalStatistics(                        in_zone_data=scratch_berm,                        zone_field=oidfield,                        in_value_raster=scratch_dem,                        statistics_type="MINIMUM",                    )                    out_raster.save(scratch_dem_mask)                    berm_elevation = out_raster.minimum + berm_height                    # clip original dem to berm area                    log("clipping dem to berm")                    out_raster = arcpy.sa.ExtractByMask(                        in_raster=scratch_dem,                        in_mask_data=scratch_berm,                        extraction_area="INSIDE",                    )                    out_raster.save(scratch_dem_mask)                    # adjust elevations under berm to berm elevation, leave alone higher ones                    # if DEM > berm elev, keep, else use berm elev                    log("adjusting dem to berm elevations")                    output_raster = arcpy.sa.Con(                        in_conditional_raster=scratch_dem_mask,                        in_true_raster_or_constant=scratch_dem_mask,                        in_false_raster_or_constant=berm_elevation,                        where_clause="VALUE > {}".format(berm_elevation)                    )                    output_raster.save(scratch_zonal_statistics)                else:                    # zonal statistics                    log("creating max berm height raster")                    out_raster = arcpy.sa.ZonalStatistics(                        in_zone_data=scratch_berm,                        zone_field=oidfield,                        in_value_raster=scratch_dem,                        statistics_type="MAXIMUM",                    )                    out_raster.save(scratch_zonal_statistics)                            # mosaic to new raster                log("mosaic to new raster")                arcpy.management.MosaicToNewRaster(                    input_rasters=[scratch_dem, scratch_zonal_statistics],                    output_location=arcpy.env.workspace,                    raster_dataset_name_with_extension=scratch_mosaic_raster.split("\\")[-1],                    pixel_type="32_BIT_FLOAT",                    number_of_bands=1,                    mosaic_method="LAST",                    mosaic_colormap_mode="FIRST"                )                # fill mosaic and clipped dem                log("fill mosaic")                out_mosaic_fill_raster = arcpy.sa.Fill(                    in_surface_raster=scratch_mosaic_raster,                    z_limit=None                )                out_mosaic_fill_raster.save(scratch_fill_mosaic)                log("fill DEM")                out_dem_fill_raster = arcpy.sa.Fill(                    in_surface_raster=scratch_dem,                    z_limit=None                )                out_dem_fill_raster.save(scratch_fill_dem)                # raster calculator                log("calculate elevation differences")                output_raster_calculator = arcpy.sa.RasterCalculator(                    rasters = [scratch_fill_mosaic, scratch_fill_dem],                    input_names = ["mosaic", "dem"],                    expression="mosaic - dem"                )                output_raster_calculator.save(scratch_raster_calculator)                if contour_bool:                    log("calculating contours")                    arcpy.sa.Contour(                        in_raster=scratch_raster_calculator,                        out_polyline_features=scratch_contour,                        contour_interval=1,                        base_contour=0,                        z_factor=z_unit,                    )                    # append contour outputs contour_output                    log("appending contour output to feature class")                    arcpy.management.Append(scratch_contour, contour_output, "NO_TEST")                # con                log("find all positive values")                out_con = arcpy.sa.Con(                    in_conditional_raster=scratch_raster_calculator,                    in_true_raster_or_constant=1,                    in_false_raster_or_constant=None,                    where_clause="VALUE <> 0"                )                out_con.save(scratch_con)                        # raster to polygon                log("raster to polygon")                arcpy.conversion.RasterToPolygon(                    in_raster=scratch_con,                    out_polygon_features=scratch_output,                    simplify="SIMPLIFY",                    raster_field="Value",                    create_multipart_features="SINGLE_OUTER_PART",                    max_vertices_per_feature=None                )                # append output polygon to output_file                log("appending output to output feature class")                arcpy.management.Append(scratch_output, output_file, "NO_TEST")                # get berm height if not supplied                if not supply_berm_height_bool:                    log("calculating berm height")                    arcpy.analysis.Clip(                        in_features=scratch_berm,                        clip_features=scratch_output,                        out_feature_class=scratch_effective_berm,                        cluster_tolerance=None                    )                    berm_raster = arcpy.sa.ZonalStatistics(                        in_zone_data=scratch_effective_berm,                        zone_field="OBJECTID",                        in_value_raster=scratch_dem,                        statistics_type="RANGE",                    )                    berm_height = berm_raster.maximum * z_unit                    log("berm height: ", berm_height, "ft")                           # add height to berm                log("adding berm height to berm feature attribute table")                berm[1] = berm_height                cursor.updateRow(berm)                # delete not needed scratch layers        log("delete unused layers")        arcpy.management.Delete([scratch_contour, scratch_berm, scratch_output, scratch_dem, scratch_dem_min, scratch_zonal_statistics, scratch_dem_mask, scratch_mosaic_raster, scratch_fill_mosaic, scratch_fill_dem, scratch_raster_calculator, scratch_con, scratch_effective_berm])                        # finish up        log("finishing up")        active_map.addDataFromPath(output_file)        if contour_bool:            active_map.addDataFromPath(contour_output)        # save project        log("saving project")        project.save()        returnclass DamRemoval(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Dam Removal"        self.description = "Dam Removal"        self.category = "Wetland Tools"        self.canRunInBackground = False       def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(            displayName="DEM",            name="dem",            datatype="GPRasterLayer",            parameterType="Required",            direction="Input")        param1 = arcpy.Parameter(            displayName="Analysis Area",            name="analysis_area",            datatype="GPExtent",            parameterType="Required",            direction="Input")                param1.controlCLSID = '{15F0D1C1-F783-49BC-8D16-619B8E92F668}'        param2 = arcpy.Parameter(            displayName="Output Features",            name="out_features",            datatype="DEFeatureClass",            parameterType="Required",            direction="Output")        param2.parameterDependencies = [param0.name]        param2.schema.clone = True                param3 = arcpy.Parameter(            displayName="Pond Centerline",            name="centerline",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        param3.filter.list = ["Polyline"]        param3.controlCLSID = '{60061247-BCA8-473E-A7AF-A2026DDE1C2D}' # allows line creation        param4 = arcpy.Parameter(            displayName="Ponded Area + Berm",            name="pond",            datatype="GPFeatureLayer",            parameterType="Required",            direction="Input")        param4.filter.list = ["Polygon"]        param4.controlCLSID = '{60061247-BCA8-473E-A7AF-A2026DDE1C2D}' # allows polygon creation        param5 = arcpy.Parameter(            displayName="Transect Spacing (ft)",            name="transect_spacing",            datatype="GPDouble",            parameterType="Required",            direction="Input")        param6 = arcpy.Parameter(            displayName="Transect Point Spacing (ft)",            name="transect_point_spacing",            datatype="GPDouble",            parameterType="Required",            direction="Input")        param7 = arcpy.Parameter(            displayName="Transect Width (ft)",            name="transect_width",            datatype="GPDouble",            parameterType="Required",            direction="Input")                params = [param0, param1, param2, param3, param4, param5, param6, param7]        return params    def updateParameters(self, parameters):        # default transect spacing        if parameters[5].value == None:            parameters[5].value = 30        # default transect point spacing        if parameters[6].value == None:            parameters[6].value = 30                return    def transectLine(self, stream_line, stream_vertex, transect_length):        '''returns a transect to stream_line of length transect_length at stream_vertex point        stream_line - arcpy.PolyLine() object        stream_vertex - arcpy.Point() object        transect_length - distance in meters of transect        '''        # TODO: handle end of lines, probably don't merge them because then it's more to store in-memory (?)                # epsilon        e = 1e-5                # get stream vertex        stream_vertex = stream_line.queryPointAndDistance(stream_vertex, False)        geom = stream_vertex[0]        distance = stream_vertex[1]        spatial_reference = stream_line.spatialReference        # get points immediately before and after midpoint        before = stream_line.positionAlongLine(distance-e, False)        after = stream_line.positionAlongLine(distance+e, False)        dX = after[0].X - before[0].X        dY = after[0].Y - before[0].Y        # angle of the midpoint segment        angle = atan2(dX,dY) * 180 / pi        first_tran_point = geom.pointFromAngleAndDistance(angle - 90, transect_length/2)        last_tran_point = geom.pointFromAngleAndDistance(angle + 90, transect_length/2)        dX = first_tran_point.firstPoint.X - last_tran_point.firstPoint.X        dY = first_tran_point.firstPoint.Y - last_tran_point.firstPoint.Y        transect = arcpy.Polyline(arcpy.Array((first_tran_point.firstPoint, last_tran_point.firstPoint)), spatial_reference, has_id=True)        return transect        def interpolateElevations(self, transect, dem_raster, lowpoint_elev, transect_width, transect_point_spacing, scratch_transect_points, scratch_transect_elev_points):        '''return points along transect with elevations        transect - arcpy.PolyLine() object        dem_raster - elevation raster        lowpoint_elev - elevation of streamline, considered lowpoint of constructed surface        transect_width - width of transect        transect_point_spacing - spacing between points on transect        scratch_transect_points - scratch layer for transect points        scratch_transect_elev_points - scratch layer for transect points with elevations        '''              arcpy.management.GeneratePointsAlongLines(transect, scratch_transect_points, "DISTANCE", transect_point_spacing, "", "END_POINTS", "ADD_CHAINAGE")        arcpy.sa.ExtractValuesToPoints(scratch_transect_points, dem_raster, scratch_transect_elev_points, "NONE", "VALUE_ONLY")        # iterate through transect points        # collect new points to add and interpolate elevations along them        num_points = (not not transect_width % transect_point_spacing) + int(transect_width / transect_point_spacing) + 1        slope = elev_start = elev_end = distance_start = distance_end = elev_prev = distance_prev = None        new_points = []        with arcpy.da.SearchCursor(scratch_transect_elev_points, ["SHAPE@", "RASTERVALU", "ORIG_LEN"]) as cursor:            update_points = []            idx = 0            for point in cursor:                elev, distance = point[1], point[2]                point = list(point)                # if middle streampoint, use elevation of streamline                if idx == (num_points - 1) / 2:                    elev = lowpoint_elev                    point[1] = elev                if elev == -9999:                    # start of unknown section                    if elev_prev != -9999:                        elev_start = elev_prev                        distance_start = distance_prev                    update_points.append(point)                else:                    # found end of unknown elevation data                    if elev_prev == -9999:                        # end of unknown section                        elev_end = elev                        distance_end = distance                                            # add interpolated points to list of points to be added to DEM                    if elev_start != None and elev_end != None:                        # TODO: option to make u-shaped valley instead of v-shaped using power function                        slope = (elev_end - elev_start)/(distance_end - distance_start)                        for i in update_points:                            i[1] = slope * (i[2] - distance_start) + elev_start                            new_points.append(tuple(i))                                                elev_start = elev_end                        distance_start = distance_end                        elev_end = None                        distance_end = None                        update_points = []                                            # add known elevation point to points to return                    new_points.append(list(point))                                    elev_prev = elev                distance_prev = distance                idx += 1        return new_points        def execute(self, parameters, messages):        """The source code of the tool."""        # setup        arcpy.env.overwriteOutput = True        dem_raster = parameters[0].value        extent = arcpy.Extent(XMin = parameters[1].value.XMin,                              YMin = parameters[1].value.YMin,                              XMax = parameters[1].value.XMax,                              YMax = parameters[1].value.YMax)        extent.spatialReference = parameters[1].value.spatialReference        output_file = parameters[2].valueAsText        centerline = parameters[3].value        pond = parameters[4].value        desc = arcpy.Describe(parameters[0].value)        vertical_unit = desc.spatialReference.linearUnitName        z_unit = 3.2808 if "meter" in vertical_unit.lower() else 1        transect_spacing = parameters[5].value / z_unit        transect_point_spacing = parameters[6].value / z_unit        transect_width = parameters[7].value / z_unit        # project setup        project = arcpy.mp.ArcGISProject("Current")        active_map = project.activeMap        # create scratch layers        scratch_dem = arcpy.CreateScratchName("scratch_dem", data_type="RasterDataset", workspace=arcpy.env.scratchFolder)        dem_pondless = "{}\\dem_pondless".format(arcpy.env.workspace)        scratch_centerline_points = arcpy.CreateScratchName("scratch_centerline_points", data_type="FeatureClass", workspace=arcpy.env.scratchFolder)                  scratch_centerline_elev_points = arcpy.CreateScratchName("scratch_centerline_elev_points", data_type="FeatureClass", workspace=arcpy.env.scratchFolder)                  scratch_point_raster = arcpy.CreateScratchName("point_raster", data_type="RasterDataset", workspace=arcpy.env.scratchFolder)                  scratch_mosaic_raster = arcpy.CreateUniqueName("scratch_mosaic_raster")        scratch_transect_points = arcpy.CreateScratchName("scratch_transect_points", data_type="FeatureClass", workspace=arcpy.env.scratchFolder)                  scratch_transect_elev_points = arcpy.CreateScratchName("scratch_transect_elev_points", data_type="FeatureClass", workspace=arcpy.env.scratchFolder)                  scratch_final_idw_points_path = arcpy.CreateScratchName("scratch_final_idw_points", data_type="FeatureClass", workspace=arcpy.env.scratchFolder)        idw_raster = arcpy.CreateScratchName("idw_raster", data_type="RasterDataset", workspace=arcpy.env.scratchFolder)        # clip raster to analysis area        log("clipping dem")        rectangle = "{} {} {} {}".format(extent.XMin, extent.YMin, extent.XMax, extent.YMax)        arcpy.management.Clip(dem_raster, rectangle, scratch_dem)        # extract by mask to remove pond from dem        log("removing ponded area from dem")        dem_pondless_output = arcpy.sa.ExtractByMask(scratch_dem, pond, "OUTSIDE", rectangle)        dem_pondless_output.save(dem_pondless)        # generate points along line        log("generating points along centerline")        arcpy.management.GeneratePointsAlongLines(centerline, scratch_centerline_points, "DISTANCE", transect_spacing, "", "END_POINTS", "ADD_CHAINAGE")        # getting number of transects        count_result = arcpy.management.GetCount(scratch_centerline_points)        record_count = int(count_result[0])                # extract values to points        log("adding elevation data to centerline points")        arcpy.sa.ExtractValuesToPoints(scratch_centerline_points, dem_pondless, scratch_centerline_elev_points, "NONE", "VALUE_ONLY")        # iterate through centerline points        log("finding known centerline points")        slope = elev_high = elev_low = distance_high = distance_low = elev_prev = distance_prev = None        with arcpy.da.SearchCursor(scratch_centerline_elev_points, ["RASTERVALU", "ORIG_LEN"]) as cursor:            for point in cursor:                if elev_high != None and elev_low != None:                    break                elev, distance = point[0], point[1]                if elev_prev != None:                    if elev == -9999 and elev_prev != -9999:                        # elev low                        elev_low = elev_prev                        distance_low = distance_prev                    elif elev != -9999 and elev_prev == -9999:                        # elev high                        elev_high = elev                        distance_high = distance                elev_prev = elev                distance_prev = distance            # calculate slope between known points        log("calculating centerline slope")        slope = (elev_high - elev_low)/(distance_high - distance_low)        # iterate and add elevations to unknown points        log("inferring unknown point elevations along centerline")        with arcpy.da.UpdateCursor(scratch_centerline_elev_points, ["RASTERVALU", "ORIG_LEN"]) as cursor:            for point in cursor:                elev, distance = point[0], point[1]                if elev == -9999:                    point[0] = slope * (distance - distance_low) + elev_low                cursor.updateRow(point)        # do we still need this mosaic? A - no, we can just pass the elevation        # Points to Raster        log("creating raster from new points")        arcpy.conversion.PointToRaster(scratch_centerline_elev_points, "RASTERVALU", scratch_point_raster, cellsize=3)        # Mosaic dem_pondless, raster_points        log("mosaic to new raster")        mosaic_raster = scratch_mosaic_raster.split("\\")[-1]        arcpy.management.MosaicToNewRaster(            input_rasters=[dem_pondless, scratch_point_raster],            output_location=arcpy.env.workspace,            raster_dataset_name_with_extension=mosaic_raster,            pixel_type="32_BIT_FLOAT",            number_of_bands=1,            mosaic_method="LAST",            mosaic_colormap_mode="FIRST"        )        # get polyline from centerline for use in transects        # note - doesn't support multiple centerlines in fc        log("getting stream centerline")        centerline_polyline = None        with arcpy.da.SearchCursor(centerline, ["SHAPE@"]) as cursor:            for line in cursor:                centerline_polyline = line[0]        # iterate through each point        # impove point density with transects using the new mosaic        # TODO: progress bar        log("creating transects and interpolating elevations")        new_points = []        with arcpy.da.SearchCursor(scratch_centerline_elev_points, ["SHAPE@", "RASTERVALU", "ORIG_LEN"]) as cursor:            for point in cursor:                # read in values                shape, elev, distance = point[0], point[1], point[2]                # create transect                  transect = self.transectLine(centerline_polyline, shape, transect_width)                # interpolate elevations                tmp_points = self.interpolateElevations(transect, mosaic_raster, elev, transect_width, transect_point_spacing, scratch_transect_points, scratch_transect_elev_points)                # add points to list of new points                new_points = new_points + tmp_points        # add points to final point fc        log("adding interpolated points to fc")        scratch_final_idw_points = arcpy.management.CreateFeatureclass(arcpy.env.scratchFolder, "scratch_final_idw_points", "POINT", scratch_centerline_elev_points)         with arcpy.da.InsertCursor(scratch_final_idw_points, ["SHAPE@", "RASTERVALU", "ORIG_LEN"]) as cursor:            for point in new_points:                cursor.insertRow(point)                # IDW or Global Polynomial Interpolation        ## depends whether we want to IDW points (must include all points then) or want to fill in DEM and interpolate voids        log("performing IDW analysis on interpolated points")        out_idw = arcpy.sa.Idw(scratch_final_idw_points, "RASTERVALU")        out_idw.save(idw_raster)        # TODO: remove any values greater than original greatest value in DEM ponded area        # extract by mask        log("extracting ponded area from IDW raster")        raster_output = arcpy.sa.ExtractByMask(idw_raster, pond, "INSIDE", rectangle)        raster_output.save(output_file)                # add results to map        log("adding results to map")        rem_raster = active_map.addDataFromPath(output_file)        # update raster symbology        log("updating raster symbology")        sym = rem_raster.symbology        if hasattr(sym, 'colorizer'):            if sym.colorizer.type != "RasterStretchColorizer":                sym.updateColorizer("RasterStretchColorizer")            sym.colorizer.stretchType = "MinimumMaximum"            sym.colorizer.colorRamp = project.listColorRamps('Slope')[0]            rem_raster.symbology = sym        # delete scratch variables        log("deleting unneeded data")        # scratch_final_idw_points_path, scratch_mosaic_raster, scratch_centerline_elev_points        arcpy.management.Delete([scratch_dem,dem_pondless,scratch_centerline_points,scratch_point_raster,scratch_transect_points,scratch_transect_elev_points,idw_raster])        # save project        log("saving project")        project.save()        return